
*作者：Dom 和 Ye Zhang* 

*致谢：感谢 _Vitalik Buterin, Yi Sun, Haichen Shen, Mohammad Jahanram, Soul Wallet 和 Safe 团队的反馈和审阅。*

*翻译：Kesling, Scroll CN*

## 介绍

智能合约钱包是大规模应用下，引入下一个十亿用户不可或缺的一部分。常规的 EOA 钱包没有可编程性且可能丢失或泄露助记词，与之相比，智能合约钱包解锁了一系列新功能，例如 2FA、gas 补贴、社交恢复等等。 Vitalik 在他的文章《[The Three Transitions](https://vitalik.eth.limo/general/2023/06/09/three_transitions.html)》中解释了在整个生态中采用智能钱包的必要性。

在本文中，我们将深入探讨当今钱包的现状、我们的发展方向，以及引入密钥库将如何发挥为用户带来无缝体验的作用。


## 钱包的现在和未来

如今，链上发生的绝大多数活动都是通过称为 EOA 钱包进行的。这些传统钱包带有助记词，用户必须尽自己所能确保其安全。此外，EOA 钱包对于新用户来说存在很大的进入门槛，比如在与 Dapp 交互之前必须先购买 ETH，因为 Gas 费必须用 ETH 支付。

虽然原生加密货币用户已经习惯了，但它依然安全性和用户体验方面依然存在一些问题。当用户仍然需要安全地存储助记词、了解什么是 Gas 的时候，希望全球可以大规模采用区块链是不现实的。

在理想的世界中，所有的技术细节都应该从用户那里抽象出来，他们应该能够拥有更像标准 web2 的用户体验，但增加了 web3 的数据所有权、自我托管、去中心化等特性。这就是智能合约钱包可以发挥作用的地方，它可以帮助用户在处理链上资产时免去许多麻烦。

智能钱包的主要优势源于将签名密钥与帐户分开。对于 EOA 钱包，唯一可用的验证机制是验证数字签名的有效性，但对于智能合约钱包，交易可以通过任意代码进行验证，这可以增加任意额外的规则。类似多签、受信保管、大额交易额外签名等。

使用智能合约钱包，您可以拥有更好、更抽象的钱包体验，所有签名逻辑都位于一个地方，处理多个不同的地址，但这只适用于该链。一旦你在另一条链上拥有资产，智能合约钱包之间的同步就成为一个问题。由于存在所有不同的 Rollup 和其他 L2 链，期望用户在每个链上部署相同的钱包，并在需要更新密钥或增加签名人时重复在不同链上执行相同的交易并不现实。对于隐私要求较高的用户来说，这更是一个问题，因为他们必须跨链管理更多地址。

_相互独立的智能合约钱包处理不同链上的不同账户_


因此，即使是具有最佳用户体验的智能合约钱包在解决这类碎片问题时也无能为力。但理想情况下，用户应当无需为每个链部署和处理钱包，这是我们通过 密钥库 旨在解决的重要问题。


## 密钥库下的多链钱包终局

密钥库 是最初由 Vitalik 提出的一种架构，他将其描述为未来多链账户抽象的最终解决方案。从本质上讲，密钥库 是智能合约钱包基础设施中的一个新组件，它将验证逻辑和资产持有分开，这意味着您的资产可以分散在多个地方，但验证您可以使用它们的所有代码都位于一个地方：密钥库。

_现在，所有智能合约钱包都会自动与密钥库中的数据同步_

通过 密钥库，用户无需管理多个不同链上的不同账户，而是可以在一个地方管理与密钥创建、轮换、恢复等相关的所有事务以及支出规则。对密钥库所做的更改会自动反映在不同链上的所有支持智能钱包中，从而极大地改善用户体验。


## 为链上用户带来隐私


通过将验证逻辑与资产持有逻辑分离，密钥库 可以超越多链钱包管理的范畴，为那些想要持有不同地址而不将它们公开关联在一起的用户带来隐私优势。单单使用智能合约钱包，如果用户同时（或大约）同时触发所有帐户的某种恢复机制，则可能将所有帐户的关联性暴露。但现在有了 密钥库，您就可以拥有一个分层且确定性的钱包，可以处理许多地址，而无需将它们公开关联在一起，即使您最终需要更改主密钥或进行一些社交恢复。类似地，密钥库 架构也可以与隐身地址方案很好地结合在一起。

此外，密钥库 与零知识证明结合使用可以帮助带来更多隐私性：

_通过 zk 证明，用户可以证明他们可以根据其 密钥库 支出规则来支出资产，而无需透露他们正在访问的 密钥库 中的哪些数据，甚至他们是谁。_

根据这个方案（由 Vitalik 在他的《[The Three Transitions](https://vitalik.eth.limo/general/2023/06/09/three_transitions.html)》文章中所提出），花费资金需要​​ zkSNARK 证明，本质上是“加密”交易和密钥库数据之间的指针，并证明用户满足所有支出条件。值得注意的是，这些证明除了“满足支出条件外”没有透露任何信息。这使得用户可以轻松管理不同账户的资金，而无需将它们公开链接在一起。


## 如何构建密钥库

密钥库可以通过不同的方式实现，而每种方式都有自己的取舍。由于我们希望数据存储在一个位置并且可以从多个外部位置获取使用，我们可以从下两个方面考虑可选项：读/写成本和数据安全性。在讨论 Scroll 的创新方案之前，让我们先简要了解一下目前的可选项。

### 将所有内容存储在以太坊 L1 上

_L2 上的帐户可以通过访问 L1 上的密钥来验证_

存储关键数据最自然能想到的是以太坊 L1，因为这是最安全的链，具有最佳的可用性和最终确认性保证。此外，Rollup 节​​点通常已经设置为读取发布到以太坊 L1 的数据，因为它们的日常操作都依赖于它。

这个选项的优势是减少了用户的信任假设，他们始终可以提交 L1 交易来更新关键数据。这符合以太坊可信中立的理念，保留用户对其数据的所有权。这种方法的一个缺点是更新关键数据的 L1 交易会变得昂贵，导致用户无法使用密钥库。为了了解 Gas 成本的开销，如果更新 L1 上的密钥涉及两次 `SSTORE` ，每次 20,000 Gas，加上至少 1 次 `ecrecover` 调用花费 3000 Gas。如果签名方案涉及 secp256r1 曲线，则又需要 200,000 个 Gas。按照牛市的 Gas 价格，单次更新的成本很容易达到 70 到 270 美元之间。因此需要一种更便宜的解决方案。

### 将所有内容存储在 L2 上

似乎下一个最好的办法是将关键数据放在任何给定的 Rollup 上，这样更新数据的成本很低。


_上图中，密钥库放在 Scroll 上，所以 Optimism 上的钱包必须先访问 Scroll 的状态根才能读取 Keystore 数据_


其工作原理是让其他 Rollup 首先从 L1 读取存储关键数据的 Rollup 的状态根，然后验证钱包软件提供的 Merkle 证明。上图中，密钥库位于 Scroll 上。同样位于 Scroll 上的帐户可以轻松访问密钥库数据，但 Optimism 上的帐户必须先获得 L1 上的 Scroll 状态根并使用它来验证证明。

这样，其他 Rollup 上的智能合约就可以满足您有权访问您正在使用的钱包的要求。这里的缺点是每次需要访问钱包数据时验证 Merkle 证明的成本会增加。

这种方案的另一个主要缺点是，你将受到该特定 Rollup 的安全性（有关活性、抗审查和最终确认性）的约束。来自此 Rollup 的所有更新都必须传播到其他 Rollup ，这会增加一些摩擦，并且如果存储关键数据的 Rollup 出现问题，可能会出问题。


### 使用专用密钥库  Rollup 

我们可以通过使用专用的最小化 Rollup 来尽可能降低上述方案相关的风险，该 Rollup 的唯一任务是处理用户的钱包数据。这种方法的读取和写入成本都较低。而且由于它受攻击和漏洞的可能性要比通用 Rollup 低得多，因此它也会更加安全。

_Rollup 上的钱包通过首先访问密钥库 Rollup 的状态根来读取密钥库_


除了所使用的证明方案将经过专门设计和优化，来达到较低的验证成本低且易于聚合的证明。这种方案的工作流程与上面的类似，其中所有 Rollup 都可以访问密钥库 Rollup 的状态根并验证证明。

然而，这种方案会存在先有鸡还是先有蛋的问题：如果今天要部署这样一个专用密钥库 Rollup，那么一开始不会发生很多密钥更新，这意味着 i) 批处理效率较低，并且每次更新的个人成本较高，或者 ii) 最终确认的时间较长，这会导致关键更新的长时间延迟，这两者都会阻碍大规模采用。长期来看，更新关键数据的单独成本只有在大批次内才能有效摊销。此外，密钥库 Rollup 将附带自己的存储树，该存储树尚未在 L2 生态系统中标准化，因此在验证 Merkle 树路径的机制方面增加了一些摩擦成本。


### 混合方案

理想情况下，我们希望有一个解决方案能够立即使用户受益，同时为专用密钥库 Rollup 的最终解决方案奠定基础。在 Scroll，我们共同的愿景是智能合约钱包的最终阶段是上述的专用密钥库，我们的目标是通过我们创新的混合方案帮助生态系统朝这个方向前进：将数据存储在 L1 上，但允许从 L2 进行更新。这样，数据就存在于以太坊上，在那里它尽可能安全，并且读取数据非常便宜，同时将更昂贵的操作委托给用户选择的 L2。此外，不太频繁的密钥更新操作现在与 L2 上的交易一起进行批处理，解决了上一节中提到的问题。

毫无疑问，Scroll 是处理这些密钥更新的第一选择，因为我们已经在零知识证明中聚合了计算——这些更新只是“又一笔交易”，不会产生不必要的开销。这种方法的主要取舍与安全性和活性假设有关：更新 L1 数据会将密钥更新活性和安全性与 Scroll 的活性和安全性联系起来。在所有 L2 中，Scroll 最坚定地致力于通过多重证明者等方法不断提高安全性。然而，为了进一步减少信任假设，我们提出了一种混合方法，用户可以选择任何 L2 作为其主链来更新密钥，因此用户可以选择信任谁，而不是仅信任 Scroll。当然这只能发生在具有快速最终确认性的 zkRollup 上，以确保关键的更新可以及时完成。我们还启用 L1 作为交易失败时的备用解决方案。我们认为，相比这种方案的所有优势，信任假设的取舍是可以接受的。对于更技术的开发者，可以在此处找到 Scroll 密钥库 v1 设计的规范。

https://hackmd.io/@haichen/keystore


_密钥库位于 L1，但可以从用户选择的 L2 进行更新（在本例中为 Scroll）_

## 如何支持密钥库

为了支持所有不同的密钥库方法， L2 需要能够安全、快速且无需信任地访问 L1 状态。这里涉及到安全性的取舍，具体取决于所涉及的 L2 的类型。

在 Scroll，我们新引入了一个强大的名为 l1sload 的预编译合约，它允许 L2 合约有效地读取存储在 L1 上的数据，而不需要大量的 Merkle 证明。这基本上意味着从 L1 读取数据的成本被转移到排序器，从而简化了 dapp 开发者的工作，否则他们必须自己获取数据，并且依赖 L1 数据的每个 L2 交易中包含 Merkle 证明。与异步 Merkle 证明方案相比，这还具有从 L1 进行同步读取的优势。这是 Optimism 团队设想的，通过使用称为远程静态调用的类似结构来执行 L1 上的函数。但是，这种从 L2 更新密钥的混合方法只有在最终确认性时间更短的 zkRollups 上才真正可行，因为它们不依赖于欺诈证明的时间窗口。

## Safe 的现场演示

随着在以太坊上的广泛采用，Safe 的多签是通过密钥库增强现有智能钱包来实现跨链同步的完美示例。如今，拥有跨多个链的多签金库的团队更新其签名者列表时，需要在每个链上进行交易。

在 Safecon Berlin 上，Scroll 团队演示了密钥库的 POC 实现，以展示如何解决跨链钱包管理问题。在现场演示中，当以太坊上的更改反映到 Scroll 时，Scroll 和以太坊 Sepolia 测试网上会自动保持签名者同步。

实现这一点的方案是，Scroll 上的 Safe 只需读取以太坊上的签名列表即可验证 L2 上的交易签名，而不是为以太坊和 Scroll 提供两个需要单独更新的不同签名者列表。这是一个简单但功能强大的展示，展示了密钥库模式与 Scroll 的 l1Sload 预编译相结合可以简化跨链钱包管理。


## 不仅仅是密钥和地址


正如我们在上面所看到的，密钥库可以实现隐身地址方案和多链密钥管理。然而，它远比这还要强大。换句话说，密钥库架构引入了一种强大的模式，将信息存储在一个地方，然后从许多不同的地方轻松访问该信息。通过 Layer 2 之间的异步消息传递将可以解锁新的跨链用例，因为它提供了一种新的原语，钱包软件可以利用该原语从用户那里抽象出更多的技术细节。有关此类用例的更多信息，请继续关注我们未来的博客文章！


## 结论

我们已经展示了智能合约钱包如何成为链上用户体验的未来之选，以及密钥库如何成为钱包基础设施的必要组成部分，从而吸引下一个十亿用户。我们相信 Scroll 实现密钥库的创新方案将帮助整个生态系统朝着正确的方向前进。如果您是钱包开发者并且有兴趣构建此功能，请随时联系 Scroll 团队！

